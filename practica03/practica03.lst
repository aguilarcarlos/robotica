CCS PCM C Compiler, Version 4.010, 35536               14-nov.-13 09:51

               Filename: practica03.lst

               ROM used: 981 words (12%)
                         Largest free fragment is 2048
               RAM used: 34 (9%) at main() level
                         67 (18%) worst case
               Stack:    8 worst case (2 in main + 6 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   354
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.4
001A:  GOTO   01D
001B:  BTFSC  0B.1
001C:  GOTO   034
001D:  BTFSS  0B.5
001E:  GOTO   021
001F:  BTFSC  0B.2
0020:  GOTO   037
0021:  MOVF   22,W
0022:  MOVWF  04
0023:  MOVF   23,W
0024:  MOVWF  77
0025:  MOVF   24,W
0026:  MOVWF  78
0027:  MOVF   25,W
0028:  MOVWF  79
0029:  MOVF   26,W
002A:  MOVWF  7A
002B:  MOVF   27,W
002C:  MOVWF  7B
002D:  MOVF   20,W
002E:  MOVWF  0A
002F:  SWAPF  21,W
0030:  MOVWF  03
0031:  SWAPF  7F,F
0032:  SWAPF  7F,W
0033:  RETFIE
0034:  BCF    0A.3
0035:  BCF    0A.4
0036:  GOTO   0F4
0037:  BCF    0A.3
0038:  BCF    0A.4
0039:  GOTO   2DF
.................... #include <16f877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses XT,NOWDT, PUT, NOWRT 
.................... #use delay(clock=4000000) 
*
01E0:  MOVLW  51
01E1:  MOVWF  04
01E2:  BCF    03.7
01E3:  MOVF   00,W
01E4:  BTFSC  03.2
01E5:  GOTO   1F4
01E6:  MOVLW  01
01E7:  MOVWF  78
01E8:  CLRF   77
01E9:  DECFSZ 77,F
01EA:  GOTO   1E9
01EB:  DECFSZ 78,F
01EC:  GOTO   1E8
01ED:  MOVLW  4A
01EE:  MOVWF  77
01EF:  DECFSZ 77,F
01F0:  GOTO   1EF
01F1:  GOTO   1F2
01F2:  DECFSZ 00,F
01F3:  GOTO   1E6
01F4:  RETLW  00
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined use_portb_lcd 
....................    #locate lcd = getenv("sfr:PORTB")    // This puts the entire structure over the port 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #locate lcd = getenv("sfr:PORTD")    // This puts the entire structure over the port 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
0186:  MOVLW  F0
0187:  BSF    03.5
0188:  MOVWF  08
....................       lcd.rw = 1; 
0189:  BCF    03.5
018A:  BSF    08.2
....................       delay_cycles(1); 
018B:  NOP
....................       lcd.enable = 1; 
018C:  BSF    08.0
....................       delay_cycles(1); 
018D:  NOP
....................       high = lcd.data; 
018E:  MOVF   08,W
018F:  SWAPF  08,W
0190:  ANDLW  0F
0191:  MOVWF  58
....................       lcd.enable = 0; 
0192:  BCF    08.0
....................       delay_cycles(1); 
0193:  NOP
....................       lcd.enable = 1; 
0194:  BSF    08.0
....................       delay_us(1); 
0195:  NOP
....................       low = lcd.data; 
0196:  MOVF   08,W
0197:  SWAPF  08,W
0198:  ANDLW  0F
0199:  MOVWF  57
....................       lcd.enable = 0; 
019A:  BCF    08.0
....................       set_tris_lcd(LCD_WRITE); 
019B:  MOVLW  00
019C:  BSF    03.5
019D:  MOVWF  08
....................       return( (high<<4) | low); 
019E:  BCF    03.5
019F:  SWAPF  58,W
01A0:  MOVWF  77
01A1:  MOVLW  F0
01A2:  ANDWF  77,F
01A3:  MOVF   77,W
01A4:  IORWF  57,W
01A5:  MOVWF  78
.................... } 
01A6:  RETLW  00
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
01A7:  SWAPF  58,W
01A8:  ANDLW  F0
01A9:  MOVWF  77
01AA:  MOVLW  0F
01AB:  ANDWF  08,W
01AC:  IORWF  77,W
01AD:  MOVWF  08
....................       delay_cycles(1); 
01AE:  NOP
....................       lcd.enable = 1; 
01AF:  BSF    08.0
....................       delay_us(2); 
01B0:  GOTO   1B1
....................       lcd.enable = 0; 
01B1:  BCF    08.0
.................... } 
01B2:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
01B3:  BCF    08.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
01B4:  CALL   186
01B5:  MOVF   78,W
01B6:  MOVWF  57
01B7:  BTFSC  57.7
01B8:  GOTO   1B4
....................       lcd.rs = address; 
01B9:  BTFSS  55.0
01BA:  BCF    08.1
01BB:  BTFSC  55.0
01BC:  BSF    08.1
....................       delay_cycles(1); 
01BD:  NOP
....................       lcd.rw = 0; 
01BE:  BCF    08.2
....................       delay_cycles(1); 
01BF:  NOP
....................       lcd.enable = 0; 
01C0:  BCF    08.0
....................       lcd_send_nibble(n >> 4); 
01C1:  SWAPF  56,W
01C2:  MOVWF  57
01C3:  MOVLW  0F
01C4:  ANDWF  57,F
01C5:  MOVF   57,W
01C6:  MOVWF  58
01C7:  CALL   1A7
....................       lcd_send_nibble(n & 0xf); 
01C8:  MOVF   56,W
01C9:  ANDLW  0F
01CA:  MOVWF  57
01CB:  MOVWF  58
01CC:  CALL   1A7
.................... } 
01CD:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
*
038C:  MOVLW  00
038D:  BSF    03.5
038E:  MOVWF  08
....................     lcd.rs = 0; 
038F:  BCF    03.5
0390:  BCF    08.1
....................     lcd.rw = 0; 
0391:  BCF    08.2
....................     lcd.enable = 0; 
0392:  BCF    08.0
0393:  CLRF   28
0394:  BTFSC  0B.7
0395:  BSF    28.7
0396:  BCF    0B.7
....................     delay_ms(15); 
0397:  MOVLW  0F
0398:  MOVWF  51
0399:  CALL   1E0
039A:  BTFSC  28.7
039B:  BSF    0B.7
....................     for(i=1;i<=3;++i) { 
039C:  MOVLW  01
039D:  MOVWF  3C
039E:  MOVF   3C,W
039F:  SUBLW  03
03A0:  BTFSS  03.0
03A1:  GOTO   3B6
03A2:  CLRF   28
03A3:  BTFSC  0B.7
03A4:  BSF    28.7
03A5:  BCF    0B.7
....................        lcd_send_nibble(3); 
03A6:  MOVLW  03
03A7:  MOVWF  58
03A8:  CALL   1A7
03A9:  BTFSC  28.7
03AA:  BSF    0B.7
03AB:  CLRF   28
03AC:  BTFSC  0B.7
03AD:  BSF    28.7
03AE:  BCF    0B.7
....................        delay_ms(5); 
03AF:  MOVLW  05
03B0:  MOVWF  51
03B1:  CALL   1E0
03B2:  BTFSC  28.7
03B3:  BSF    0B.7
....................     } 
03B4:  INCF   3C,F
03B5:  GOTO   39E
03B6:  CLRF   28
03B7:  BTFSC  0B.7
03B8:  BSF    28.7
03B9:  BCF    0B.7
....................     lcd_send_nibble(2); 
03BA:  MOVLW  02
03BB:  MOVWF  58
03BC:  CALL   1A7
03BD:  BTFSC  28.7
03BE:  BSF    0B.7
....................     for(i=0;i<=3;++i) 
03BF:  CLRF   3C
03C0:  MOVF   3C,W
03C1:  SUBLW  03
03C2:  BTFSS  03.0
03C3:  GOTO   3D3
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
03C4:  MOVF   3C,W
03C5:  CALL   03A
03C6:  MOVWF  3D
03C7:  CLRF   28
03C8:  BTFSC  0B.7
03C9:  BSF    28.7
03CA:  BCF    0B.7
03CB:  CLRF   55
03CC:  MOVF   3D,W
03CD:  MOVWF  56
03CE:  CALL   1B3
03CF:  BTFSC  28.7
03D0:  BSF    0B.7
03D1:  INCF   3C,F
03D2:  GOTO   3C0
.................... } 
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
01CE:  DECFSZ 52,W
01CF:  GOTO   1D1
01D0:  GOTO   1D4
....................      address=lcd_line_two; 
01D1:  MOVLW  40
01D2:  MOVWF  53
....................    else 
01D3:  GOTO   1D5
....................      address=0; 
01D4:  CLRF   53
....................    address+=x-1; 
01D5:  MOVLW  01
01D6:  SUBWF  51,W
01D7:  ADDWF  53,F
....................    lcd_send_byte(0,0x80|address); 
01D8:  MOVF   53,W
01D9:  IORLW  80
01DA:  MOVWF  54
01DB:  CLRF   55
01DC:  MOVF   54,W
01DD:  MOVWF  56
01DE:  CALL   1B3
.................... } 
01DF:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
*
01F5:  MOVF   50,W
01F6:  XORLW  0C
01F7:  BTFSC  03.2
01F8:  GOTO   200
01F9:  XORLW  06
01FA:  BTFSC  03.2
01FB:  GOTO   208
01FC:  XORLW  02
01FD:  BTFSC  03.2
01FE:  GOTO   20E
01FF:  GOTO   213
....................      case '\f'   : lcd_send_byte(0,1); 
0200:  CLRF   55
0201:  MOVLW  01
0202:  MOVWF  56
0203:  CALL   1B3
....................                    delay_ms(2); 
0204:  MOVLW  02
0205:  MOVWF  51
0206:  CALL   1E0
....................                                            break; 
0207:  GOTO   219
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0208:  MOVLW  01
0209:  MOVWF  51
020A:  MOVLW  02
020B:  MOVWF  52
020C:  CALL   1CE
020D:  GOTO   219
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
020E:  CLRF   55
020F:  MOVLW  10
0210:  MOVWF  56
0211:  CALL   1B3
0212:  GOTO   219
....................      default     : lcd_send_byte(1,c);     break; 
0213:  MOVLW  01
0214:  MOVWF  55
0215:  MOVF   50,W
0216:  MOVWF  56
0217:  CALL   1B3
0218:  GOTO   219
....................    } 
.................... } 
0219:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
035F:  BCF    03.5
0360:  CLRF   29
0361:  CLRF   2A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... int32 pulsos, velocidad,pulsos1; 
.................... float distancia; 
....................  
.................... #use fast_io(B) 
.................... #INT_EXT        
.................... ext_isr() 
.................... { 
.................... 	if ((input(PIN_B0)==1)&(input(PIN_B1)==0)) 
*
00F4:  MOVLW  00
00F5:  BTFSC  06.0
00F6:  MOVLW  01
00F7:  MOVWF  44
00F8:  MOVLW  00
00F9:  BTFSS  06.1
00FA:  MOVLW  01
00FB:  ANDWF  44,W
00FC:  BTFSC  03.2
00FD:  GOTO   11A
....................     { 
....................     	pulsos = pulsos+1; 
00FE:  MOVLW  01
00FF:  ADDWF  2B,F
0100:  MOVLW  00
0101:  BTFSC  03.0
0102:  MOVLW  01
0103:  ADDWF  2C,F
0104:  MOVLW  00
0105:  BTFSC  03.0
0106:  MOVLW  01
0107:  ADDWF  2D,F
0108:  MOVLW  00
0109:  BTFSC  03.0
010A:  MOVLW  01
010B:  ADDWF  2E,F
....................     	pulsos1 = pulsos1+1;	 
010C:  MOVLW  01
010D:  ADDWF  33,F
010E:  MOVLW  00
010F:  BTFSC  03.0
0110:  MOVLW  01
0111:  ADDWF  34,F
0112:  MOVLW  00
0113:  BTFSC  03.0
0114:  MOVLW  01
0115:  ADDWF  35,F
0116:  MOVLW  00
0117:  BTFSC  03.0
0118:  MOVLW  01
0119:  ADDWF  36,F
....................     } 
....................      
....................     if ((input(PIN_B0)==1)&(input(PIN_B1)==1)) 
011A:  MOVLW  00
011B:  BTFSC  06.0
011C:  MOVLW  01
011D:  MOVWF  44
011E:  MOVLW  00
011F:  BTFSC  06.1
0120:  MOVLW  01
0121:  ANDWF  44,W
0122:  BTFSC  03.2
0123:  GOTO   140
....................     { 
....................     	pulsos = pulsos-1; 
0124:  MOVLW  01
0125:  SUBWF  2B,F
0126:  MOVLW  00
0127:  BTFSS  03.0
0128:  MOVLW  01
0129:  SUBWF  2C,F
012A:  MOVLW  00
012B:  BTFSS  03.0
012C:  MOVLW  01
012D:  SUBWF  2D,F
012E:  MOVLW  00
012F:  BTFSS  03.0
0130:  MOVLW  01
0131:  SUBWF  2E,F
....................     	pulsos1 = pulsos1+1; 
0132:  MOVLW  01
0133:  ADDWF  33,F
0134:  MOVLW  00
0135:  BTFSC  03.0
0136:  MOVLW  01
0137:  ADDWF  34,F
0138:  MOVLW  00
0139:  BTFSC  03.0
013A:  MOVLW  01
013B:  ADDWF  35,F
013C:  MOVLW  00
013D:  BTFSC  03.0
013E:  MOVLW  01
013F:  ADDWF  36,F
....................     } 
....................      
.................... 	distancia = pulsos * 0.65;	 
0140:  MOVF   2E,W
0141:  MOVWF  46
0142:  MOVF   2D,W
0143:  MOVWF  45
0144:  MOVF   2C,W
0145:  MOVWF  44
0146:  MOVF   2B,W
0147:  MOVWF  43
0148:  CALL   064
0149:  MOVF   7A,W
014A:  MOVWF  46
014B:  MOVF   79,W
014C:  MOVWF  45
014D:  MOVF   78,W
014E:  MOVWF  44
014F:  MOVF   77,W
0150:  MOVWF  43
0151:  MOVLW  66
0152:  MOVWF  4A
0153:  MOVWF  49
0154:  MOVLW  26
0155:  MOVWF  48
0156:  MOVLW  7E
0157:  MOVWF  47
0158:  CALL   07F
0159:  MOVF   7A,W
015A:  MOVWF  3A
015B:  MOVF   79,W
015C:  MOVWF  39
015D:  MOVF   78,W
015E:  MOVWF  38
015F:  MOVF   77,W
0160:  MOVWF  37
.................... } 
....................  
0161:  BCF    0B.1
0162:  BCF    0A.3
0163:  BCF    0A.4
0164:  GOTO   021
.................... int Contador = 250; 
*
0362:  MOVLW  FA
0363:  MOVWF  3B
....................  
.................... #INT_TIMER0 
.................... void interruption() 
.................... { 
.................... 	set_timer0(6); 
*
02DF:  MOVLW  06
02E0:  MOVWF  01
.................... 	Contador--; 
02E1:  DECFSZ 3B,F
.................... 	if(Contador == 0) 
02E2:  GOTO   350
.................... 	{ 
.................... 		velocidad = pulsos1 * 0.65; 
02E3:  MOVF   36,W
02E4:  MOVWF  46
02E5:  MOVF   35,W
02E6:  MOVWF  45
02E7:  MOVF   34,W
02E8:  MOVWF  44
02E9:  MOVF   33,W
02EA:  MOVWF  43
02EB:  CALL   064
02EC:  MOVF   7A,W
02ED:  MOVWF  46
02EE:  MOVF   79,W
02EF:  MOVWF  45
02F0:  MOVF   78,W
02F1:  MOVWF  44
02F2:  MOVF   77,W
02F3:  MOVWF  43
02F4:  MOVLW  66
02F5:  MOVWF  4A
02F6:  MOVWF  49
02F7:  MOVLW  26
02F8:  MOVWF  48
02F9:  MOVLW  7E
02FA:  MOVWF  47
02FB:  CALL   07F
02FC:  MOVF   7A,W
02FD:  MOVWF  46
02FE:  MOVF   79,W
02FF:  MOVWF  45
0300:  MOVF   78,W
0301:  MOVWF  44
0302:  MOVF   77,W
0303:  MOVWF  43
0304:  GOTO   165
0305:  MOVF   7A,W
0306:  MOVWF  32
0307:  MOVF   79,W
0308:  MOVWF  31
0309:  MOVF   78,W
030A:  MOVWF  30
030B:  MOVF   77,W
030C:  MOVWF  2F
.................... 		lcd_gotoxy(1,1); 
030D:  MOVLW  01
030E:  MOVWF  51
030F:  MOVWF  52
0310:  CALL   1CE
.................... 		printf(lcd_putc,"Pulsos=%Ld \n",pulsos);  
0311:  CLRF   43
0312:  MOVF   43,W
0313:  CALL   042
0314:  INCF   43,F
0315:  MOVWF  77
0316:  MOVWF  50
0317:  CALL   1F5
0318:  MOVLW  07
0319:  SUBWF  43,W
031A:  BTFSS  03.2
031B:  GOTO   312
031C:  MOVLW  41
031D:  MOVWF  04
031E:  MOVF   2E,W
031F:  MOVWF  47
0320:  MOVF   2D,W
0321:  MOVWF  46
0322:  MOVF   2C,W
0323:  MOVWF  45
0324:  MOVF   2B,W
0325:  MOVWF  44
0326:  CALL   25C
0327:  MOVLW  20
0328:  MOVWF  50
0329:  CALL   1F5
032A:  MOVLW  0A
032B:  MOVWF  50
032C:  CALL   1F5
....................     	printf(lcd_putc,"V=%Ld cm/seg",velocidad); 
032D:  MOVLW  56
032E:  MOVWF  50
032F:  CALL   1F5
0330:  MOVLW  3D
0331:  MOVWF  50
0332:  CALL   1F5
0333:  MOVLW  41
0334:  MOVWF  04
0335:  MOVF   32,W
0336:  MOVWF  47
0337:  MOVF   31,W
0338:  MOVWF  46
0339:  MOVF   30,W
033A:  MOVWF  45
033B:  MOVF   2F,W
033C:  MOVWF  44
033D:  CALL   25C
033E:  MOVLW  05
033F:  MOVWF  43
0340:  MOVF   43,W
0341:  CALL   053
0342:  INCF   43,F
0343:  MOVWF  77
0344:  MOVWF  50
0345:  CALL   1F5
0346:  MOVLW  0C
0347:  SUBWF  43,W
0348:  BTFSS  03.2
0349:  GOTO   340
.................... 		pulsos1 = 0; 
034A:  CLRF   36
034B:  CLRF   35
034C:  CLRF   34
034D:  CLRF   33
.................... 		Contador = 250; 
034E:  MOVLW  FA
034F:  MOVWF  3B
.................... 			 
.................... 	}	 
.................... } 
....................      
0350:  BCF    0B.2
0351:  BCF    0A.3
0352:  BCF    0A.4
0353:  GOTO   021
.................... void main() { 
0354:  CLRF   04
0355:  BCF    03.7
0356:  MOVLW  1F
0357:  ANDWF  03,F
0358:  BSF    03.5
0359:  BSF    1F.0
035A:  BSF    1F.1
035B:  BSF    1F.2
035C:  BCF    1F.3
035D:  MOVLW  07
035E:  MOVWF  1C
....................    //Inicializo la variable pulsos en el codigo principal 
....................    pulsos = 0; 
*
0364:  CLRF   2E
0365:  CLRF   2D
0366:  CLRF   2C
0367:  CLRF   2B
....................     
....................    // Activar puerto B como entrada 
....................    set_tris_B(0x01);  
0368:  MOVLW  01
0369:  BSF    03.5
036A:  MOVWF  06
....................     
....................    port_b_pullups(TRUE); 
036B:  BCF    01.7
....................    enable_interrupts(int_ext); 
036C:  BCF    03.5
036D:  BSF    0B.4
....................    ext_int_edge(L_to_H); 
036E:  BSF    03.5
036F:  BSF    01.6
....................    setup_counters(RTCC_INTERNAL,RTCC_DIV_16); 
0370:  MOVLW  03
0371:  MOVWF  77
0372:  BTFSS  77.3
0373:  GOTO   37F
0374:  MOVLW  07
0375:  BCF    03.5
0376:  CLRF   01
0377:  MOVLW  81
0378:  MOVWF  04
0379:  BCF    03.7
037A:  MOVF   00,W
037B:  ANDLW  C0
037C:  IORLW  0F
037D:  MOVWF  00
037E:  BSF    03.5
037F:  CLRWDT
0380:  MOVLW  81
0381:  MOVWF  04
0382:  MOVF   00,W
0383:  ANDLW  C0
0384:  IORWF  77,W
0385:  MOVWF  00
....................    set_timer0(6); 
0386:  MOVLW  06
0387:  BCF    03.5
0388:  MOVWF  01
....................    enable_interrupts(INT_TIMER0); 
0389:  BSF    0B.5
....................    enable_interrupts(GLOBAL); 
038A:  MOVLW  C0
038B:  IORWF  0B,F
....................    lcd_init(); //Esta es la primera instrucción para inicializar el lcd 
....................     
....................    while(TRUE)  
....................    { 
.................... 	    
....................    } 
*
03D3:  GOTO   3D3
.................... } 
....................      
....................           
03D4:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
