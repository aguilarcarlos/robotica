CCS PCM C Compiler, Version 4.010, 35536               12-nov.-13 13:32

               Filename: practica03.lst

               ROM used: 1074 words (13%)
                         Largest free fragment is 2048
               RAM used: 25 (7%) at main() level
                         59 (16%) worst case
               Stack:    8 worst case (2 in main + 6 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   3CC
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  MOVF   7B,W
0016:  MOVWF  27
0017:  BCF    03.7
0018:  BCF    03.5
0019:  BTFSS  0B.4
001A:  GOTO   01D
001B:  BTFSC  0B.1
001C:  GOTO   030
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   27,W
0028:  MOVWF  7B
0029:  MOVF   20,W
002A:  MOVWF  0A
002B:  SWAPF  21,W
002C:  MOVWF  03
002D:  SWAPF  7F,F
002E:  SWAPF  7F,W
002F:  RETFIE
0030:  BCF    0A.3
0031:  BCF    0A.4
0032:  GOTO   336
.................... #include <16f877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #fuses XT,NOWDT, PUT, NOWRT 
.................... #use delay(clock=4000000) 
*
0148:  MOVLW  49
0149:  MOVWF  04
014A:  BCF    03.7
014B:  MOVF   00,W
014C:  BTFSC  03.2
014D:  GOTO   15C
014E:  MOVLW  01
014F:  MOVWF  78
0150:  CLRF   77
0151:  DECFSZ 77,F
0152:  GOTO   151
0153:  DECFSZ 78,F
0154:  GOTO   150
0155:  MOVLW  4A
0156:  MOVWF  77
0157:  DECFSZ 77,F
0158:  GOTO   157
0159:  GOTO   15A
015A:  DECFSZ 00,F
015B:  GOTO   14E
015C:  RETLW  00
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined use_portb_lcd 
....................    #locate lcd = getenv("sfr:PORTB")    // This puts the entire structure over the port 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #locate lcd = getenv("sfr:PORTD")    // This puts the entire structure over the port 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
00EE:  MOVLW  F0
00EF:  BSF    03.5
00F0:  MOVWF  08
....................       lcd.rw = 1; 
00F1:  BCF    03.5
00F2:  BSF    08.2
....................       delay_cycles(1); 
00F3:  NOP
....................       lcd.enable = 1; 
00F4:  BSF    08.0
....................       delay_cycles(1); 
00F5:  NOP
....................       high = lcd.data; 
00F6:  MOVF   08,W
00F7:  SWAPF  08,W
00F8:  ANDLW  0F
00F9:  MOVWF  50
....................       lcd.enable = 0; 
00FA:  BCF    08.0
....................       delay_cycles(1); 
00FB:  NOP
....................       lcd.enable = 1; 
00FC:  BSF    08.0
....................       delay_us(1); 
00FD:  NOP
....................       low = lcd.data; 
00FE:  MOVF   08,W
00FF:  SWAPF  08,W
0100:  ANDLW  0F
0101:  MOVWF  4F
....................       lcd.enable = 0; 
0102:  BCF    08.0
....................       set_tris_lcd(LCD_WRITE); 
0103:  MOVLW  00
0104:  BSF    03.5
0105:  MOVWF  08
....................       return( (high<<4) | low); 
0106:  BCF    03.5
0107:  SWAPF  50,W
0108:  MOVWF  77
0109:  MOVLW  F0
010A:  ANDWF  77,F
010B:  MOVF   77,W
010C:  IORWF  4F,W
010D:  MOVWF  78
.................... } 
010E:  RETLW  00
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
010F:  SWAPF  50,W
0110:  ANDLW  F0
0111:  MOVWF  77
0112:  MOVLW  0F
0113:  ANDWF  08,W
0114:  IORWF  77,W
0115:  MOVWF  08
....................       delay_cycles(1); 
0116:  NOP
....................       lcd.enable = 1; 
0117:  BSF    08.0
....................       delay_us(2); 
0118:  GOTO   119
....................       lcd.enable = 0; 
0119:  BCF    08.0
.................... } 
011A:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
011B:  BCF    08.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
011C:  CALL   0EE
011D:  MOVF   78,W
011E:  MOVWF  4F
011F:  BTFSC  4F.7
0120:  GOTO   11C
....................       lcd.rs = address; 
0121:  BTFSS  4D.0
0122:  BCF    08.1
0123:  BTFSC  4D.0
0124:  BSF    08.1
....................       delay_cycles(1); 
0125:  NOP
....................       lcd.rw = 0; 
0126:  BCF    08.2
....................       delay_cycles(1); 
0127:  NOP
....................       lcd.enable = 0; 
0128:  BCF    08.0
....................       lcd_send_nibble(n >> 4); 
0129:  SWAPF  4E,W
012A:  MOVWF  4F
012B:  MOVLW  0F
012C:  ANDWF  4F,F
012D:  MOVF   4F,W
012E:  MOVWF  50
012F:  CALL   10F
....................       lcd_send_nibble(n & 0xf); 
0130:  MOVF   4E,W
0131:  ANDLW  0F
0132:  MOVWF  4F
0133:  MOVWF  50
0134:  CALL   10F
.................... } 
0135:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
*
03E9:  MOVLW  00
03EA:  BSF    03.5
03EB:  MOVWF  08
....................     lcd.rs = 0; 
03EC:  BCF    03.5
03ED:  BCF    08.1
....................     lcd.rw = 0; 
03EE:  BCF    08.2
....................     lcd.enable = 0; 
03EF:  BCF    08.0
03F0:  CLRF   28
03F1:  BTFSC  0B.7
03F2:  BSF    28.7
03F3:  BCF    0B.7
....................     delay_ms(15); 
03F4:  MOVLW  0F
03F5:  MOVWF  49
03F6:  CALL   148
03F7:  BTFSC  28.7
03F8:  BSF    0B.7
....................     for(i=1;i<=3;++i) { 
03F9:  MOVLW  01
03FA:  MOVWF  33
03FB:  MOVF   33,W
03FC:  SUBLW  03
03FD:  BTFSS  03.0
03FE:  GOTO   413
03FF:  CLRF   28
0400:  BTFSC  0B.7
0401:  BSF    28.7
0402:  BCF    0B.7
....................        lcd_send_nibble(3); 
0403:  MOVLW  03
0404:  MOVWF  50
0405:  CALL   10F
0406:  BTFSC  28.7
0407:  BSF    0B.7
0408:  CLRF   28
0409:  BTFSC  0B.7
040A:  BSF    28.7
040B:  BCF    0B.7
....................        delay_ms(5); 
040C:  MOVLW  05
040D:  MOVWF  49
040E:  CALL   148
040F:  BTFSC  28.7
0410:  BSF    0B.7
....................     } 
0411:  INCF   33,F
0412:  GOTO   3FB
0413:  CLRF   28
0414:  BTFSC  0B.7
0415:  BSF    28.7
0416:  BCF    0B.7
....................     lcd_send_nibble(2); 
0417:  MOVLW  02
0418:  MOVWF  50
0419:  CALL   10F
041A:  BTFSC  28.7
041B:  BSF    0B.7
....................     for(i=0;i<=3;++i) 
041C:  CLRF   33
041D:  MOVF   33,W
041E:  SUBLW  03
041F:  BTFSS  03.0
0420:  GOTO   430
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
0421:  MOVF   33,W
0422:  CALL   033
0423:  MOVWF  34
0424:  CLRF   28
0425:  BTFSC  0B.7
0426:  BSF    28.7
0427:  BCF    0B.7
0428:  CLRF   4D
0429:  MOVF   34,W
042A:  MOVWF  4E
042B:  CALL   11B
042C:  BTFSC  28.7
042D:  BSF    0B.7
042E:  INCF   33,F
042F:  GOTO   41D
.................... } 
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
0136:  DECFSZ 4A,W
0137:  GOTO   139
0138:  GOTO   13C
....................      address=lcd_line_two; 
0139:  MOVLW  40
013A:  MOVWF  4B
....................    else 
013B:  GOTO   13D
....................      address=0; 
013C:  CLRF   4B
....................    address+=x-1; 
013D:  MOVLW  01
013E:  SUBWF  49,W
013F:  ADDWF  4B,F
....................    lcd_send_byte(0,0x80|address); 
0140:  MOVF   4B,W
0141:  IORLW  80
0142:  MOVWF  4C
0143:  CLRF   4D
0144:  MOVF   4C,W
0145:  MOVWF  4E
0146:  CALL   11B
.................... } 
0147:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
*
015D:  MOVF   48,W
015E:  XORLW  0C
015F:  BTFSC  03.2
0160:  GOTO   168
0161:  XORLW  06
0162:  BTFSC  03.2
0163:  GOTO   170
0164:  XORLW  02
0165:  BTFSC  03.2
0166:  GOTO   176
0167:  GOTO   17B
....................      case '\f'   : lcd_send_byte(0,1); 
0168:  CLRF   4D
0169:  MOVLW  01
016A:  MOVWF  4E
016B:  CALL   11B
....................                    delay_ms(2); 
016C:  MOVLW  02
016D:  MOVWF  49
016E:  CALL   148
....................                                            break; 
016F:  GOTO   181
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0170:  MOVLW  01
0171:  MOVWF  49
0172:  MOVLW  02
0173:  MOVWF  4A
0174:  CALL   136
0175:  GOTO   181
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
0176:  CLRF   4D
0177:  MOVLW  10
0178:  MOVWF  4E
0179:  CALL   11B
017A:  GOTO   181
....................      default     : lcd_send_byte(1,c);     break; 
017B:  MOVLW  01
017C:  MOVWF  4D
017D:  MOVF   48,W
017E:  MOVWF  4E
017F:  CALL   11B
0180:  GOTO   181
....................    } 
.................... } 
0181:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
03D7:  BCF    03.5
03D8:  CLRF   29
03D9:  CLRF   2A
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... int32 pulsos; 
.................... float distancia; 
....................  
.................... #use fast_io(B) 
.................... #INT_EXT 
....................  
.................... //Interrupción externa         
.................... ext_isr() 
.................... { 
.................... 	if ((input(PIN_B0)==1)&(input(PIN_B1)==0)) 
*
0336:  MOVLW  00
0337:  BTFSC  06.0
0338:  MOVLW  01
0339:  MOVWF  3B
033A:  MOVLW  00
033B:  BTFSS  06.1
033C:  MOVLW  01
033D:  ANDWF  3B,W
033E:  BTFSC  03.2
033F:  GOTO   34E
....................     { 
....................     	pulsos = pulsos+1;	 
0340:  MOVLW  01
0341:  ADDWF  2B,F
0342:  MOVLW  00
0343:  BTFSC  03.0
0344:  MOVLW  01
0345:  ADDWF  2C,F
0346:  MOVLW  00
0347:  BTFSC  03.0
0348:  MOVLW  01
0349:  ADDWF  2D,F
034A:  MOVLW  00
034B:  BTFSC  03.0
034C:  MOVLW  01
034D:  ADDWF  2E,F
....................     } 
....................      
....................     if ((input(PIN_B0)==1)&(input(PIN_B1)==1)) 
034E:  MOVLW  00
034F:  BTFSC  06.0
0350:  MOVLW  01
0351:  MOVWF  3B
0352:  MOVLW  00
0353:  BTFSC  06.1
0354:  MOVLW  01
0355:  ANDWF  3B,W
0356:  BTFSC  03.2
0357:  GOTO   366
....................     { 
....................     	pulsos = pulsos-1; 
0358:  MOVLW  01
0359:  SUBWF  2B,F
035A:  MOVLW  00
035B:  BTFSS  03.0
035C:  MOVLW  01
035D:  SUBWF  2C,F
035E:  MOVLW  00
035F:  BTFSS  03.0
0360:  MOVLW  01
0361:  SUBWF  2D,F
0362:  MOVLW  00
0363:  BTFSS  03.0
0364:  MOVLW  01
0365:  SUBWF  2E,F
....................     } 
....................      
.................... 	distancia = pulsos * 0.65; 
0366:  MOVF   2E,W
0367:  MOVWF  3D
0368:  MOVF   2D,W
0369:  MOVWF  3C
036A:  MOVF   2C,W
036B:  MOVWF  3B
036C:  MOVF   2B,W
036D:  MOVWF  3A
036E:  GOTO   05C
036F:  MOVF   7A,W
0370:  MOVWF  4B
0371:  MOVF   79,W
0372:  MOVWF  4A
0373:  MOVF   78,W
0374:  MOVWF  49
0375:  MOVF   77,W
0376:  MOVWF  48
0377:  MOVLW  66
0378:  MOVWF  4F
0379:  MOVWF  4E
037A:  MOVLW  26
037B:  MOVWF  4D
037C:  MOVLW  7E
037D:  MOVWF  4C
037E:  CALL   079
037F:  MOVF   7A,W
0380:  MOVWF  32
0381:  MOVF   79,W
0382:  MOVWF  31
0383:  MOVF   78,W
0384:  MOVWF  30
0385:  MOVF   77,W
0386:  MOVWF  2F
.................... 	 
....................     lcd_gotoxy(1,1); 
0387:  MOVLW  01
0388:  MOVWF  49
0389:  MOVWF  4A
038A:  CALL   136
....................     printf(lcd_putc,"Pulsos=%Ld \n",pulsos);  
038B:  CLRF   3A
038C:  MOVF   3A,W
038D:  CALL   03B
038E:  INCF   3A,F
038F:  MOVWF  77
0390:  MOVWF  48
0391:  CALL   15D
0392:  MOVLW  07
0393:  SUBWF  3A,W
0394:  BTFSS  03.2
0395:  GOTO   38C
0396:  MOVLW  41
0397:  MOVWF  04
0398:  MOVF   2E,W
0399:  MOVWF  3E
039A:  MOVF   2D,W
039B:  MOVWF  3D
039C:  MOVF   2C,W
039D:  MOVWF  3C
039E:  MOVF   2B,W
039F:  MOVWF  3B
03A0:  GOTO   1C4
03A1:  MOVLW  20
03A2:  MOVWF  48
03A3:  CALL   15D
03A4:  MOVLW  0A
03A5:  MOVWF  48
03A6:  CALL   15D
....................     printf(lcd_putc,"Dist=%Lf cm",distancia); 
03A7:  CLRF   3A
03A8:  MOVF   3A,W
03A9:  CALL   04C
03AA:  INCF   3A,F
03AB:  MOVWF  77
03AC:  MOVWF  48
03AD:  CALL   15D
03AE:  MOVLW  05
03AF:  SUBWF  3A,W
03B0:  BTFSS  03.2
03B1:  GOTO   3A8
03B2:  MOVLW  89
03B3:  MOVWF  04
03B4:  MOVF   32,W
03B5:  MOVWF  3E
03B6:  MOVF   31,W
03B7:  MOVWF  3D
03B8:  MOVF   30,W
03B9:  MOVWF  3C
03BA:  MOVF   2F,W
03BB:  MOVWF  3B
03BC:  MOVLW  02
03BD:  MOVWF  3F
03BE:  GOTO   26A
03BF:  MOVLW  20
03C0:  MOVWF  48
03C1:  CALL   15D
03C2:  MOVLW  63
03C3:  MOVWF  48
03C4:  CALL   15D
03C5:  MOVLW  6D
03C6:  MOVWF  48
03C7:  CALL   15D
.................... } 
....................      
03C8:  BCF    0B.1
03C9:  BCF    0A.3
03CA:  BCF    0A.4
03CB:  GOTO   01D
.................... void main() { 
03CC:  CLRF   04
03CD:  BCF    03.7
03CE:  MOVLW  1F
03CF:  ANDWF  03,F
03D0:  BSF    03.5
03D1:  BSF    1F.0
03D2:  BSF    1F.1
03D3:  BSF    1F.2
03D4:  BCF    1F.3
03D5:  MOVLW  07
03D6:  MOVWF  1C
.................... 	//Inicializo la variable pulsos en el codigo principal 
....................    pulsos = 0; 
*
03DA:  CLRF   2E
03DB:  CLRF   2D
03DC:  CLRF   2C
03DD:  CLRF   2B
....................    set_tris_B(0x01);  
03DE:  MOVLW  01
03DF:  BSF    03.5
03E0:  MOVWF  06
....................    port_b_pullups(TRUE); 
03E1:  BCF    01.7
....................    enable_interrupts(int_ext); 
03E2:  BCF    03.5
03E3:  BSF    0B.4
....................    ext_int_edge(L_to_H); 
03E4:  BSF    03.5
03E5:  BSF    01.6
....................    enable_interrupts(GLOBAL); 
03E6:  MOVLW  C0
03E7:  BCF    03.5
03E8:  IORWF  0B,F
....................    lcd_init(); //Esta es la primera instrucción para inicializar el lcd 
....................     
....................    while(TRUE)  
....................    { 
.................... 	    
....................    } 
*
0430:  GOTO   430
.................... } 
....................      
....................           
0431:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
