CCS PCM C Compiler, Version 4.010, 35536               09-dic.-13 15:07

               Filename: practica04.lst

               ROM used: 1054 words (13%)
                         Largest free fragment is 2048
               RAM used: 21 (6%) at main() level
                         47 (13%) worst case
               Stack:    5 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   2C8
0003:  NOP
.................... #include <16F877a.H> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
.................... #device ADC=10 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float atof(char * s); 
....................  
.................... /* Standard template: float atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int32 atoi32(char *s); 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, int8 base, char * s); 
....................  
.................... /* Standard template: signed long  atol(char * s) 
....................  * converts the initial portion of the string s to a signed long 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float strtol(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... float strtod(char *s,char *endptr); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr,signed int base); 
....................  
.................... /* Standard template: long strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... long strtoul(char *s,char *endptr,signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... long rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer,signed int denom); 
.................... ldiv_t ldiv(signed long numer,signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  (x==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  (x<' ') 
.................... #define isprint(x)  (x>=' ') 
.................... #define isgraph(x)  (x>' ') 
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
02D3:  BCF    03.5
02D4:  CLRF   20
02D5:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer,signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer,signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float atof(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0; 
....................    int expsign = 0; 
....................    char c; 
....................    int ptr = 0; 
....................    int i; 
....................    float exp = 1.0; 
....................    int expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... char * itoa(signed int32 num, int8 base, char *s) 
.................... { 
....................      int32 temp=1; 
....................      int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtod(char *s,char *endptr) { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int sign = 0, point = 0; 
....................    char c; 
....................    int ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................          *((char *)endptr)=s+ptr; 
....................       } 
....................       else 
....................          *((char *)endptr)=s; 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... long strtoul(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-') 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................  
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr,signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................       return 0; 
....................    } 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................       if (endptr) 
....................       { 
....................         *((char *)endptr)=s; 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................         *((char *)endptr)=sc; 
....................    return x; 
.................... } 
....................  
.................... signed int system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... long rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned long)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, int qitems, int qsize, _Cmpfun cmp) { 
....................    int m,j,i,l; 
....................    short done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #fuses XT, NOWDT, NOPROTECT, BROWNOUT, PUT, NOLVP 
.................... #use delay(clock=4000000) 
*
000C:  MOVLW  3D
000D:  MOVWF  04
000E:  BCF    03.7
000F:  MOVF   00,W
0010:  BTFSC  03.2
0011:  GOTO   020
0012:  MOVLW  01
0013:  MOVWF  78
0014:  CLRF   77
0015:  DECFSZ 77,F
0016:  GOTO   015
0017:  DECFSZ 78,F
0018:  GOTO   014
0019:  MOVLW  4A
001A:  MOVWF  77
001B:  DECFSZ 77,F
001C:  GOTO   01B
001D:  GOTO   01E
001E:  DECFSZ 00,F
001F:  GOTO   012
0020:  RETLW  00
.................... #include <LCD.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined use_portb_lcd 
....................    #locate lcd = getenv("sfr:PORTB")    // This puts the entire structure over the port 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #locate lcd = getenv("sfr:PORTD")    // This puts the entire structure over the port 
....................    #define set_tris_lcd(x) set_tris_d(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
002E:  MOVLW  F0
002F:  BSF    03.5
0030:  MOVWF  08
....................       lcd.rw = 1; 
0031:  BCF    03.5
0032:  BSF    08.2
....................       delay_cycles(1); 
0033:  NOP
....................       lcd.enable = 1; 
0034:  BSF    08.0
....................       delay_cycles(1); 
0035:  NOP
....................       high = lcd.data; 
0036:  MOVF   08,W
0037:  SWAPF  08,W
0038:  ANDLW  0F
0039:  MOVWF  44
....................       lcd.enable = 0; 
003A:  BCF    08.0
....................       delay_cycles(1); 
003B:  NOP
....................       lcd.enable = 1; 
003C:  BSF    08.0
....................       delay_us(1); 
003D:  NOP
....................       low = lcd.data; 
003E:  MOVF   08,W
003F:  SWAPF  08,W
0040:  ANDLW  0F
0041:  MOVWF  43
....................       lcd.enable = 0; 
0042:  BCF    08.0
....................       set_tris_lcd(LCD_WRITE); 
0043:  MOVLW  00
0044:  BSF    03.5
0045:  MOVWF  08
....................       return( (high<<4) | low); 
0046:  BCF    03.5
0047:  SWAPF  44,W
0048:  MOVWF  77
0049:  MOVLW  F0
004A:  ANDWF  77,F
004B:  MOVF   77,W
004C:  IORWF  43,W
004D:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
0021:  SWAPF  44,W
0022:  ANDLW  F0
0023:  MOVWF  77
0024:  MOVLW  0F
0025:  ANDWF  08,W
0026:  IORWF  77,W
0027:  MOVWF  08
....................       delay_cycles(1); 
0028:  NOP
....................       lcd.enable = 1; 
0029:  BSF    08.0
....................       delay_us(2); 
002A:  GOTO   02B
....................       lcd.enable = 0; 
002B:  BCF    08.0
.................... } 
002C:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
002D:  BCF    08.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
004E:  MOVF   78,W
004F:  MOVWF  43
0050:  BTFSC  43.7
0051:  GOTO   02E
....................       lcd.rs = address; 
0052:  BTFSS  41.0
0053:  BCF    08.1
0054:  BTFSC  41.0
0055:  BSF    08.1
....................       delay_cycles(1); 
0056:  NOP
....................       lcd.rw = 0; 
0057:  BCF    08.2
....................       delay_cycles(1); 
0058:  NOP
....................       lcd.enable = 0; 
0059:  BCF    08.0
....................       lcd_send_nibble(n >> 4); 
005A:  SWAPF  42,W
005B:  MOVWF  43
005C:  MOVLW  0F
005D:  ANDWF  43,F
005E:  MOVF   43,W
005F:  MOVWF  44
0060:  CALL   021
....................       lcd_send_nibble(n & 0xf); 
0061:  MOVF   42,W
0062:  ANDLW  0F
0063:  MOVWF  43
0064:  MOVWF  44
0065:  CALL   021
.................... } 
0066:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
0067:  MOVLW  00
0068:  BSF    03.5
0069:  MOVWF  08
....................     lcd.rs = 0; 
006A:  BCF    03.5
006B:  BCF    08.1
....................     lcd.rw = 0; 
006C:  BCF    08.2
....................     lcd.enable = 0; 
006D:  BCF    08.0
....................     delay_ms(15); 
006E:  MOVLW  0F
006F:  MOVWF  3D
0070:  CALL   00C
....................     for(i=1;i<=3;++i) { 
0071:  MOVLW  01
0072:  MOVWF  2F
0073:  MOVF   2F,W
0074:  SUBLW  03
0075:  BTFSS  03.0
0076:  GOTO   07F
....................        lcd_send_nibble(3); 
0077:  MOVLW  03
0078:  MOVWF  44
0079:  CALL   021
....................        delay_ms(5); 
007A:  MOVLW  05
007B:  MOVWF  3D
007C:  CALL   00C
....................     } 
007D:  INCF   2F,F
007E:  GOTO   073
....................     lcd_send_nibble(2); 
007F:  MOVLW  02
0080:  MOVWF  44
0081:  CALL   021
....................     for(i=0;i<=3;++i) 
0082:  CLRF   2F
0083:  MOVF   2F,W
0084:  SUBLW  03
0085:  BTFSS  03.0
0086:  GOTO   090
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
0087:  MOVF   2F,W
0088:  CALL   004
0089:  MOVWF  30
008A:  CLRF   41
008B:  MOVF   30,W
008C:  MOVWF  42
008D:  CALL   02D
008E:  INCF   2F,F
008F:  GOTO   083
.................... } 
0090:  BCF    0A.3
0091:  BCF    0A.4
0092:  GOTO   2E8 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
0125:  DECFSZ 3E,W
0126:  GOTO   128
0127:  GOTO   12B
....................      address=lcd_line_two; 
0128:  MOVLW  40
0129:  MOVWF  3F
....................    else 
012A:  GOTO   12C
....................      address=0; 
012B:  CLRF   3F
....................    address+=x-1; 
012C:  MOVLW  01
012D:  SUBWF  3D,W
012E:  ADDWF  3F,F
....................    lcd_send_byte(0,0x80|address); 
012F:  MOVF   3F,W
0130:  IORLW  80
0131:  MOVWF  40
0132:  CLRF   41
0133:  MOVF   40,W
0134:  MOVWF  42
0135:  CALL   02D
.................... } 
0136:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
*
019A:  MOVF   3C,W
019B:  XORLW  0C
019C:  BTFSC  03.2
019D:  GOTO   1A5
019E:  XORLW  06
019F:  BTFSC  03.2
01A0:  GOTO   1AD
01A1:  XORLW  02
01A2:  BTFSC  03.2
01A3:  GOTO   1B3
01A4:  GOTO   1B8
....................      case '\f'   : lcd_send_byte(0,1); 
01A5:  CLRF   41
01A6:  MOVLW  01
01A7:  MOVWF  42
01A8:  CALL   02D
....................                    delay_ms(2); 
01A9:  MOVLW  02
01AA:  MOVWF  3D
01AB:  CALL   00C
....................                                            break; 
01AC:  GOTO   1BE
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
01AD:  MOVLW  01
01AE:  MOVWF  3D
01AF:  MOVLW  02
01B0:  MOVWF  3E
01B1:  CALL   125
01B2:  GOTO   1BE
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
01B3:  CLRF   41
01B4:  MOVLW  10
01B5:  MOVWF  42
01B6:  CALL   02D
01B7:  GOTO   1BE
....................      default     : lcd_send_byte(1,c);     break; 
01B8:  MOVLW  01
01B9:  MOVWF  41
01BA:  MOVF   3C,W
01BB:  MOVWF  42
01BC:  CALL   02D
01BD:  GOTO   1BE
....................    } 
.................... } 
01BE:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #byte port_b=0x06 
....................  
.................... void main() 
.................... { 
*
02C8:  CLRF   04
02C9:  BCF    03.7
02CA:  MOVLW  1F
02CB:  ANDWF  03,F
02CC:  BSF    03.5
02CD:  BSF    1F.0
02CE:  BSF    1F.1
02CF:  BSF    1F.2
02D0:  BCF    1F.3
02D1:  MOVLW  07
02D2:  MOVWF  1C
....................  
....................   float senir,senir2; 
....................   setup_adc(ADC_CLOCK_INTERNAL); 
*
02D8:  BSF    03.5
02D9:  BCF    1F.6
02DA:  BCF    03.5
02DB:  BSF    1F.6
02DC:  BSF    1F.7
02DD:  BSF    03.5
02DE:  BSF    1F.7
02DF:  BCF    03.5
02E0:  BSF    1F.0
....................   setup_adc_ports(ALL_ANALOG); 
02E1:  BSF    03.5
02E2:  BCF    1F.0
02E3:  BCF    1F.1
02E4:  BCF    1F.2
02E5:  BCF    1F.3
....................   lcd_init(); 
02E6:  BCF    03.5
02E7:  GOTO   067
....................  
....................   output_high(pin_b0); 
02E8:  BSF    03.5
02E9:  BCF    06.0
02EA:  BCF    03.5
02EB:  BSF    06.0
....................   output_low(pin_b1); 
02EC:  BSF    03.5
02ED:  BCF    06.1
02EE:  BCF    03.5
02EF:  BCF    06.1
....................  
....................   set_tris_b(0x00); 
02F0:  MOVLW  00
02F1:  BSF    03.5
02F2:  MOVWF  06
....................  
....................   setup_ccp1(ccp_PWM); 
*
02D6:  MOVLW  FF
02D7:  MOVWF  26
*
02F3:  BCF    03.5
02F4:  BCF    26.2
02F5:  MOVF   26,W
02F6:  BSF    03.5
02F7:  MOVWF  07
02F8:  BCF    03.5
02F9:  BCF    07.2
02FA:  MOVLW  0C
02FB:  MOVWF  17
....................   setup_ccp2(ccp_PWM); 
02FC:  BCF    26.1
02FD:  MOVF   26,W
02FE:  BSF    03.5
02FF:  MOVWF  07
0300:  BCF    03.5
0301:  BCF    07.1
0302:  MOVLW  0C
0303:  MOVWF  1D
....................   setup_timer_2(t2_div_By_1,249,1); 
0304:  MOVLW  00
0305:  MOVWF  78
0306:  IORLW  04
0307:  MOVWF  12
0308:  MOVLW  F9
0309:  BSF    03.5
030A:  MOVWF  12
....................  
....................   output_high(pin_b2); 
030B:  BCF    06.2
030C:  BCF    03.5
030D:  BSF    06.2
....................   output_low(pin_b3); 
030E:  BSF    03.5
030F:  BCF    06.3
0310:  BCF    03.5
0311:  BCF    06.3
....................   set_pwm1_duty(900); 
0312:  MOVLW  E1
0313:  MOVWF  15
0314:  MOVF   17,W
0315:  ANDLW  CF
0316:  MOVWF  17
....................   set_pwm2_duty(600); 
0317:  MOVLW  96
0318:  MOVWF  1B
0319:  MOVF   1D,W
031A:  ANDLW  CF
031B:  MOVWF  1D
....................  
....................   while (true) 
....................   { 
....................     set_adc_channel(0); 
031C:  MOVLW  00
031D:  MOVWF  78
031E:  MOVF   1F,W
031F:  ANDLW  C7
0320:  IORWF  78,W
0321:  MOVWF  1F
....................     delay_ms(30); 
0322:  MOVLW  1E
0323:  MOVWF  3D
0324:  CALL   00C
....................     senir=read_adc(); 
0325:  BSF    1F.2
0326:  BTFSC  1F.2
0327:  GOTO   326
0328:  MOVF   1E,W
0329:  MOVWF  7A
032A:  BSF    03.5
032B:  MOVF   1E,W
032C:  BCF    03.5
032D:  MOVWF  2F
032E:  MOVF   1E,W
032F:  MOVWF  30
0330:  CALL   093
0331:  MOVF   7A,W
0332:  MOVWF  2A
0333:  MOVF   79,W
0334:  MOVWF  29
0335:  MOVF   78,W
0336:  MOVWF  28
0337:  MOVF   77,W
0338:  MOVWF  27
....................     senir*=(float).004882; 
0339:  MOVF   2A,W
033A:  MOVWF  3F
033B:  MOVF   29,W
033C:  MOVWF  3E
033D:  MOVF   28,W
033E:  MOVWF  3D
033F:  MOVF   27,W
0340:  MOVWF  3C
0341:  MOVLW  2F
0342:  MOVWF  43
0343:  MOVLW  F9
0344:  MOVWF  42
0345:  MOVLW  1F
0346:  MOVWF  41
0347:  MOVLW  77
0348:  MOVWF  40
0349:  CALL   0B0
034A:  MOVF   7A,W
034B:  MOVWF  2A
034C:  MOVF   79,W
034D:  MOVWF  29
034E:  MOVF   78,W
034F:  MOVWF  28
0350:  MOVF   77,W
0351:  MOVWF  27
....................  
....................     set_adc_channel(1); 
0352:  MOVLW  08
0353:  MOVWF  78
0354:  MOVF   1F,W
0355:  ANDLW  C7
0356:  IORWF  78,W
0357:  MOVWF  1F
....................     delay_ms(30); 
0358:  MOVLW  1E
0359:  MOVWF  3D
035A:  CALL   00C
....................     
....................     senir2 = read_adc(); 
035B:  BSF    1F.2
035C:  BTFSC  1F.2
035D:  GOTO   35C
035E:  MOVF   1E,W
035F:  MOVWF  7A
0360:  BSF    03.5
0361:  MOVF   1E,W
0362:  BCF    03.5
0363:  MOVWF  2F
0364:  MOVF   1E,W
0365:  MOVWF  30
0366:  CALL   093
0367:  MOVF   7A,W
0368:  MOVWF  2E
0369:  MOVF   79,W
036A:  MOVWF  2D
036B:  MOVF   78,W
036C:  MOVWF  2C
036D:  MOVF   77,W
036E:  MOVWF  2B
....................     senir2 *= (float).004882; 
036F:  MOVF   2E,W
0370:  MOVWF  3F
0371:  MOVF   2D,W
0372:  MOVWF  3E
0373:  MOVF   2C,W
0374:  MOVWF  3D
0375:  MOVF   2B,W
0376:  MOVWF  3C
0377:  MOVLW  2F
0378:  MOVWF  43
0379:  MOVLW  F9
037A:  MOVWF  42
037B:  MOVLW  1F
037C:  MOVWF  41
037D:  MOVLW  77
037E:  MOVWF  40
037F:  CALL   0B0
0380:  MOVF   7A,W
0381:  MOVWF  2E
0382:  MOVF   79,W
0383:  MOVWF  2D
0384:  MOVF   78,W
0385:  MOVWF  2C
0386:  MOVF   77,W
0387:  MOVWF  2B
....................     
....................     lcd_gotoxy(1,1); 
0388:  MOVLW  01
0389:  MOVWF  3D
038A:  MOVWF  3E
038B:  CALL   125
....................     printf(lcd_putc,"%f",senir); 
038C:  MOVLW  89
038D:  MOVWF  04
038E:  MOVF   2A,W
038F:  MOVWF  32
0390:  MOVF   29,W
0391:  MOVWF  31
0392:  MOVF   28,W
0393:  MOVWF  30
0394:  MOVF   27,W
0395:  MOVWF  2F
0396:  MOVLW  02
0397:  MOVWF  33
0398:  CALL   1BF
....................     lcd_gotoxy(1,2); 
0399:  MOVLW  01
039A:  MOVWF  3D
039B:  MOVLW  02
039C:  MOVWF  3E
039D:  CALL   125
....................     printf(lcd_putc,"%f",senir2); 
039E:  MOVLW  89
039F:  MOVWF  04
03A0:  MOVF   2E,W
03A1:  MOVWF  32
03A2:  MOVF   2D,W
03A3:  MOVWF  31
03A4:  MOVF   2C,W
03A5:  MOVWF  30
03A6:  MOVF   2B,W
03A7:  MOVWF  2F
03A8:  MOVLW  02
03A9:  MOVWF  33
03AA:  CALL   1BF
....................  
....................     if (senir2>=(3.1) && senir>(3.1)) 
03AB:  MOVLW  66
03AC:  MOVWF  32
03AD:  MOVWF  31
03AE:  MOVLW  46
03AF:  MOVWF  30
03B0:  MOVLW  80
03B1:  MOVWF  2F
03B2:  MOVF   2E,W
03B3:  MOVWF  36
03B4:  MOVF   2D,W
03B5:  MOVWF  35
03B6:  MOVF   2C,W
03B7:  MOVWF  34
03B8:  MOVF   2B,W
03B9:  MOVWF  33
03BA:  CALL   289
03BB:  BTFSC  03.0
03BC:  GOTO   3BF
03BD:  BTFSS  03.2
03BE:  GOTO   3DA
03BF:  MOVLW  66
03C0:  MOVWF  32
03C1:  MOVWF  31
03C2:  MOVLW  46
03C3:  MOVWF  30
03C4:  MOVLW  80
03C5:  MOVWF  2F
03C6:  MOVF   2A,W
03C7:  MOVWF  36
03C8:  MOVF   29,W
03C9:  MOVWF  35
03CA:  MOVF   28,W
03CB:  MOVWF  34
03CC:  MOVF   27,W
03CD:  MOVWF  33
03CE:  CALL   289
03CF:  BTFSS  03.0
03D0:  GOTO   3DA
....................     { 
....................       output_low(pin_b2); 
03D1:  BSF    03.5
03D2:  BCF    06.2
03D3:  BCF    03.5
03D4:  BCF    06.2
....................       output_low(pin_b4); 
03D5:  BSF    03.5
03D6:  BCF    06.4
03D7:  BCF    03.5
03D8:  BCF    06.4
....................     } 
....................     else 
03D9:  GOTO   41C
....................     { 
....................  
....................       if (senir>=(3.1)) 
03DA:  MOVLW  66
03DB:  MOVWF  32
03DC:  MOVWF  31
03DD:  MOVLW  46
03DE:  MOVWF  30
03DF:  MOVLW  80
03E0:  MOVWF  2F
03E1:  MOVF   2A,W
03E2:  MOVWF  36
03E3:  MOVF   29,W
03E4:  MOVWF  35
03E5:  MOVF   28,W
03E6:  MOVWF  34
03E7:  MOVF   27,W
03E8:  MOVWF  33
03E9:  CALL   289
03EA:  BTFSC  03.0
03EB:  GOTO   3EE
03EC:  BTFSS  03.2
03ED:  GOTO   3F7
....................       { 
....................         output_high(pin_b2); 
03EE:  BSF    03.5
03EF:  BCF    06.2
03F0:  BCF    03.5
03F1:  BSF    06.2
....................         output_low(pin_b3); 
03F2:  BSF    03.5
03F3:  BCF    06.3
03F4:  BCF    03.5
03F5:  BCF    06.3
....................       } 
....................       else 
03F6:  GOTO   3FB
....................       { 
....................         output_low(pin_b2); 
03F7:  BSF    03.5
03F8:  BCF    06.2
03F9:  BCF    03.5
03FA:  BCF    06.2
....................       } 
....................  
....................       if (senir2>=(3.1)) 
03FB:  MOVLW  66
03FC:  MOVWF  32
03FD:  MOVWF  31
03FE:  MOVLW  46
03FF:  MOVWF  30
0400:  MOVLW  80
0401:  MOVWF  2F
0402:  MOVF   2E,W
0403:  MOVWF  36
0404:  MOVF   2D,W
0405:  MOVWF  35
0406:  MOVF   2C,W
0407:  MOVWF  34
0408:  MOVF   2B,W
0409:  MOVWF  33
040A:  CALL   289
040B:  BTFSC  03.0
040C:  GOTO   40F
040D:  BTFSS  03.2
040E:  GOTO   418
....................       { 
....................         output_low(pin_b2); 
040F:  BSF    03.5
0410:  BCF    06.2
0411:  BCF    03.5
0412:  BCF    06.2
....................         output_high(pin_b4); 
0413:  BSF    03.5
0414:  BCF    06.4
0415:  BCF    03.5
0416:  BSF    06.4
....................       } 
....................       else 
0417:  GOTO   41C
....................       { 
....................         output_low(pin_b4); 
0418:  BSF    03.5
0419:  BCF    06.4
041A:  BCF    03.5
041B:  BCF    06.4
....................       } 
....................     } 
....................   } 
041C:  GOTO   31C
.................... } 
041D:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
